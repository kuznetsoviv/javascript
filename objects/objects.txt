-------------------------------------------------------------------
-------------------------------------------------------------------
jsавтоматически недобавляет точки с запятой.
Способы создания объектов:
//
let user = new Object();
//
let user = {}

let user = {
	name: 'Jonh',
	age: 30,
	// имя свойства может быть из нескольких слов
	"likes birds": true
}

Добавление дополнительного свойства:
	user.isAdmin = true;
Удаление свойства:
	delete user.age;
К свойству объекта можно обращаться при помощи следующего синтаксиса:
	alert(user["likes birds"]);

Для объекта можно добавлять вычисляемое свойство:
	let key = "like birds";
	user[key] = true;

Имена свойств всегда преобразуются в строку.
Проверка существования свойства.
	alert("key" in user);
Обход свойств объекта:
	for (let key in user) {
		alert(user[key]);
	}
Свойства с целочисленными ключами сортируются по возврастанию.
Два объекта равны, только в том случае, если это один и тот же объект.
Метод Object.assign(dest, [src1, src2, src3...]) используется для копирования объекта.
Object.keys(user) - получение свойств объекта.

function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
-------------------------------------------------------------------
-------------------------------------------------------------------
Тип символ js:
Символы используются для задания скрытых свойств объекта, они являются уникальными идентификаторами.
Символы гарантировано всегда будут разными:
	let id1 = Symbol("id");
	let id2 = Symbol("id");
	alert(id1 == id2); //false
Вывести описание символа:
	alert(id1.description);	 
Символы не перебираются циклом (for in).
Object.assign - копирует также и символы.	
------------------------------------------------------------------
	let user = {
	  name: "Вася"
	};
	let id = Symbol("id");
	user[id] = 1;
	alert(user[id]);
------------------------------------------------------------------
Существует глобальный реестр символов:
	let id = Symbol.for("id");
	let idAgain = Symbol.for("id");
	alert(id === idAgain); // true
	Symbol.keyFor(id) // получить наименование символа
Object.getOwnPropertySymbols(obj) - используются для получения символов объекта
-------------------------------------------------------------------
-------------------------------------------------------------------
Задание функций в объекте:
	let user = {
		name: "Джон",
		hi() { alert(this.name); }
	};
	let hi = user.hi; //функция сохраняется в переменной
	hi() // вызывается сама по себе без объекта.
	user.hi(); // возвращает не саму функцию, а специальное значение ссылочного типа "Reference Type".
Reference type - это комбинация из трех значений (base, name, strict). (Пример (user, "hi", true)).
-------------------------------------------------------------------
-------------------------------------------------------------------
Преобразование объектов в примитивы:
	- в лоическом контексте все объекты являются true;
	- численные преобразования выполняются, когда мы вычитаем объекты или выполняем математические операции
		Number(obj); +obj; obj1 - obj2; obj1 > obj2;
	- строковые преобразования выполняются, когда мы ожмдаем строку для выполнения операции:
		alert(obj); anotherObj[obj] = 123;
	- есть операции для которых непонятно какое преобразование нужно выполнять:
		obj1 + obj2; if (obj1 == 1) { ... }
В процессе преобразование js пытается вызвать три следующих метода объекта:
	- obj[Symbol.toPrimitive](hint)
		let user = {
  			name: "John",
  			money: 1000,

  			[Symbol.toPrimitive](hint) {
    			alert(`hint: ${hint}`);
    			return hint == "string" ? `{name: "${this.name}"}` : this.money;
  			}
		};	
	(устаревшие методы, (хотя часто достаточно вызвать просто метод toString)):	
	- если hint == 'string', то вызываем toString(), а если его нет, то вызываем obj.valueOf()
	- если hint == 'number' или 'default', вызываем obj.valueOf(), а если его нет, то obj.toString()
-------------------------------------------------------------------
-------------------------------------------------------------------
Создание объекта через оператор new:
	function User(name) {
		// this = {};  (неявно)
		this.name = name;
  		this.isAdmin = true;
  
  		this.sayHi = function() {
    		alert( `Меня зовут:  ${this.name}`);
  		};
  		// return this;  (неявно)
	}
	let user = new User('Igor');

	new.target // внутри функции используется для проверки создалась функция при помощи оператора new или без	




 