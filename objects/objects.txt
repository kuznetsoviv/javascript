-------------------------------------------------------------------
-------------------------------------------------------------------
js автоматически недобавляет точки с запятой.
Способы создания объектов:
//
let user = new Object();
//
let user = {}

let user = {
	name: 'Jonh',
	age: 30,
	// имя свойства может быть из нескольких слов
	"likes birds": true
}

Добавление дополнительного свойства:
	user.isAdmin = true;
Удаление свойства:
	delete user.age;
К свойству объекта можно обращаться при помощи следующего синтаксиса:
	alert(user["likes birds"]);

Для объекта можно добавлять вычисляемое свойство:
	let key = "like birds";
	user[key] = true;

Имена свойств всегда преобразуются в строку.
Проверка существования свойства.
	alert("key" in user);
Обход свойств объекта:
	for (let key in user) {
		alert(user[key]);
	}
Свойства с целочисленными ключами сортируются по возврастанию.
Два объекта равны, только в том случае, если это один и тот же объект.
Метод Object.assign(dest, [src1, src2, src3...]) используется для копирования объекта.
Object.keys(user) - получение свойств объекта.

function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
-------------------------------------------------------------------
-------------------------------------------------------------------
Тип символ js:
Символы используются для задания скрытых свойств объекта, они являются уникальными идентификаторами.
Символы гарантировано всегда будут разными:
	let id1 = Symbol("id");
	let id2 = Symbol("id");
	alert(id1 == id2); //false
Вывести описание символа:
	alert(id1.description);	 
Символы не перебираются циклом (for in).
Object.assign - копирует также и символы.	
------------------------------------------------------------------
	let user = {
	  name: "Вася"
	};
	let id = Symbol("id");
	user[id] = 1;
	alert(user[id]);
------------------------------------------------------------------
Существует глобальный реестр символов:
	let id = Symbol.for("id");
	let idAgain = Symbol.for("id");
	alert(id === idAgain); // true
	Symbol.keyFor(id) // получить наименование символа
Object.getOwnPropertySymbols(obj) - используются для получения символов объекта
-------------------------------------------------------------------
-------------------------------------------------------------------
Задание функций в объекте:
	let user = {
		name: "Джон",
		hi() { alert(this.name); }
	};
	let hi = user.hi; //функция сохраняется в переменной
	hi() // вызывается сама по себе без объекта.
	user.hi(); // возвращает не саму функцию, а специальное значение ссылочного типа "Reference Type".
Reference type - это комбинация из трех значений (base, name, strict). (Пример (user, "hi", true)).
-------------------------------------------------------------------
-------------------------------------------------------------------
Преобразование объектов в примитивы:
	- в лоическом контексте все объекты являются true;
	- численные преобразования выполняются, когда мы вычитаем объекты или выполняем математические операции
		Number(obj); +obj; obj1 - obj2; obj1 > obj2;
	- строковые преобразования выполняются, когда мы ожмдаем строку для выполнения операции:
		alert(obj); anotherObj[obj] = 123;
	- есть операции для которых непонятно какое преобразование нужно выполнять:
		obj1 + obj2; if (obj1 == 1) { ... }
В процессе преобразование js пытается вызвать три следующих метода объекта:
	- obj[Symbol.toPrimitive](hint)
		let user = {
  			name: "John",
  			money: 1000,

  			[Symbol.toPrimitive](hint) {
    			alert(`hint: ${hint}`);
    			return hint == "string" ? `{name: "${this.name}"}` : this.money;
  			}
		};	
	(устаревшие методы, (хотя часто достаточно вызвать просто метод toString)):	
	- если hint == 'string', то вызываем toString(), а если его нет, то вызываем obj.valueOf()
	- если hint == 'number' или 'default', вызываем obj.valueOf(), а если его нет, то obj.toString()
-------------------------------------------------------------------
-------------------------------------------------------------------
Создание объекта через оператор new:
	function User(name) {
		// this = {};  (неявно)
		this.name = name;
  		this.isAdmin = true;
  
  		this.sayHi = function() {
    		alert( `Меня зовут:  ${this.name}`);
  		};
  		// return this;  (неявно)
	}
	let user = new User('Igor');

	new.target // внутри функции используется для проверки создалась функция при помощи оператора new или без
-------------------------------------------------------------------
-------------------------------------------------------------------
Перебираемые объекты:
	let range = {
	  from: 1,
	  to: 5,

	  [Symbol.iterator]() {
	    this.current = this.from;
	    return this;
	  },

	  next() {
	    if (this.current <= this.to) {
	      return { done: false, value: this.current++ };
	    } else {
	      return { done: true };
	    }
	  }
	};
-------------------------------------------------------------------
-------------------------------------------------------------------
Деструктуризация:
-------------------------------------------------------------------
	let arr = ["Ilya", "Kantor"]
	let [firstName, surname] = arr;		
-------------------------------------------------------------------
	let user = {};
	[user.name, user.surname] = "Ilya Kantor".split(' ');
-------------------------------------------------------------------	
	let [a, b, c] = "abc";
-------------------------------------------------------------------
	let [name = "Guest", surname = "Anonymous"] = ["Julius"];	
-------------------------------------------------------------------	
	let options = {
  		title: "Menu"
	};
	let {width = 100, height = 200, title} = options;
-------------------------------------------------------------------
-------------------------------------------------------------------
Флаги и дескрипторы свойств:
	Свойства в js помимо значения value имеют еще три специальных атрибута:
		writable - значение свойства можно изменить;
		enumerable - свойство перечисляется в цикле (for ... in) - для объекта;
		configurable - свойство можно удалить, и атрибуты свойства можно изменять
	Посмотреть полную информацию о свойстве объекта:
		let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
	Изменить значение флага:
		Object.defineProperty(obj, propertyName, descriptor);
			let user = { };
			Object.defineProperty(user, "name", {
  				value: "John",
  				writable: false,
  				configurable: false
			});
		По умолчанию заполняет все флаги значением false.
	Посмотреть информацию обо всех свойствах объекта:
		Object.getOwnPropertyDescriptors(obj);
	Глобавльное изменение объекта:
		// Запрещает добавлять новые свойства в объект.
		Object.preventExtensions(obj)
		// Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.
		Object.seal(obj)
		// Запрещает добавлять/удалять/изменять свойства. 
		Object.freeze(obj)
----------------------------------------------------------
----------------------------------------------------------
Геттеры и сеттеры:
	let user = {
  		name: "John",
  		surname: "Smith",

  		get fullName() {
    		return `${this.name} ${this.surname}`;
  		},

  		set fullName(value) {
    		[this.name, this.surname] = value.split(" ");
  		}
	};
	----------------------------------------------------------					
	Дескрипторы свойств для геттеров и сеторов отличаются от обычных свойств:
		get – функция без аргументов, которая сработает при чтении свойства,
		set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
		enumerable – то же самое, что и для свойств-данных,
		configurable – то же самое, что и для свойств-данных.
	----------------------------------------------------------
	Object.defineProperty(user, 'fullName', {
  		get() {
    		return `${this.name} ${this.surname}`;
  		},

  		set(value) {
    		[this.name, this.surname] = value.split(" ");
  		}
	});	
----------------------------------------------------------
----------------------------------------------------------
Примесь - это класс, методы которого предназначены для использования в других класах, 
	причем без наследования от примеси.
	Пример миксина:
		let sayHiMixin = {
			sayHi() {
		  	return `Hi ${this.name}`;
		  }
		}

		class User {
		  constructor(name) {
		  	this.name = name;
		  }
		}

		Object.assign(User.prototype, sayHiMixin);

		let user = new User('Igor');
		alert(user.sayHi());
 