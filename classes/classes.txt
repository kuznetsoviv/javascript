Базовый синтаксис для создания классов:
	class MyClass {
   		constructor() { ... }
  		method1() { ... }
  		method2() { ... }
  		method3() { ... }
	}
	new MyClass() - синтаксис для создания нового класса
	Определение класса:
		Класс - это разновидность функции, конструкция class User{ ... }:
			1) создает функцию с именем User, код функции берется из метода constructor;
			2) сохраняет все методы в User.prototype.
			3) также можно добавлять геттеры и сеттеры
		Особенности классов:
			1) функция конструктора отмечена внутренним свойством: [[FunctionKind]]: 'classConstructor';
			2) нельзя вызвать без new;
			3) строковое представление функции в классе начинается с class User;
			4) методы класса являются неперечислимыми;
			5) классы всегда используют use strict;	
		Поля классов создаются, как свойство объекта при вызове коструктора. 	
-------------------------------------------------------------------
-------------------------------------------------------------------
		Общие положения при наследовании:
		1) class Child extends Parent, при этом Child.prototype.__proto__ = Parent.prototype
		2) обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this
		3) super.method() - обращение к родительскому методу
		4) методы запоминают свой объект во внктреннем свойстве [[HomeObject]], super работает 
		благодаря этой особенности	
		class Animal {
			constructor(name) {
				this.name = name;
			}
		}		

		class Rabbit extends Animal {
			constructor(name) {
				super(name);
				this.created = Date.now();
			}
		}

		let rabbit = new Rabbit('Белый кролик');
		alert(rabbit.name);
-------------------------------------------------------------------
-------------------------------------------------------------------
	Статические методы класса принадлежат классу в целом, а не относятся к конкретному объекту класса,
	наследуются в потомках
	Статические свойства:
		Эти свойства добавляются к самой функции классу, а не к ее прототипу.
			class User {
  				static staticMethod() {
    				alert(this === User);
  				}
			} // тоже самое User.staticMethod = function() {...}
	Object.__proto__ == Function.protype
-------------------------------------------------------------------
-------------------------------------------------------------------
	Приватные и защищенные методы:
	1) Использование приватных свойств по соглашению программистов:
		Наименование свойства с нижним подчеркиванием (_waterAmount):
		class CoffeeMachine {
  			_waterAmount = 0;

  			setWaterAmount(value) {
    			if (value < 0) throw new Error("Отрицательное количество воды");
    			this._waterAmount = value;
  			}

  			getWaterAmount() {
    			return this._waterAmount;
  			}
		}

		new CoffeeMachine().setWaterAmount(100);

	2) использование приватных свойств на уровне языка:
		Эти свойства не видны снаружи и не могут использоваться в потомках.
		class CoffeeMachine {
  			#waterLimit = 200;
  			#checkWater(value) {
    			if (value < 0) throw new Error("Отрицательный уровень воды");
    			if (value > this.#waterLimit) throw new Error("Слишком много воды");
  			}
		}
-------------------------------------------------------------------
-------------------------------------------------------------------
	Расширение встроенных классов:
		class PowerArray extends Array {
  			isEmpty() {
    			return this.length === 0;
  			}
		}	
		При расширении коллекциий методы filter, map - 
		будут использовать конструктор расширенной коллекции (PowerArray)
		Можно указать метод static get [Symbol.species], который будет возвращать нужный конструктор:
			static get [Symbol.species]() {
    			return Array;
  			}
  		У встроенных классов отсутсвует статическое наследование от Object 
  		(то есть будут недоступны методы Object.keys() в виде Array.keys())
-------------------------------------------------------------------
-------------------------------------------------------------------
	Проверка instanceof: 		
		Оператор instanceof позволяет проверить к какому классу принадлежит объект с учетом наследования
		(работает и с функциями контрукторами)
			class Rabbit {}
			let rabbit = new Rabbit();
			alert( rabbit instanceof Rabbit );
		-------------------------------------------------------------------
		Можно задать свой метод для проверки наследования: 
		(для этого необходимо реализовать статическую функцию Symbol.hasInstance):
			class Animal {
  				static [Symbol.hasInstance](obj) {
    				if (obj.canEat) return true;
  				}
			}

			let obj = { canEat: true };
			alert(obj instanceof Animal);
		-------------------------------------------------------------------
		Метод Object.prototype.toString возвращает тип:
			let method = Object.prototype.toString;
			alert(method.call(undefined)); // [object Array]
		-------------------------------------------------------------------
		С помощью метода Symbol.toStringTag можно определять поведение метода toString:
			let user = {
  				[Symbol.toStringTag]: "User"
			};
			alert( {}.toString.call(user) ); // alert(user.toString());		


