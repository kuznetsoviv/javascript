----------------------------------------------------------
----------------------------------------------------------
Остаточные параметры и оператор расширения:
	function sumAll(...args) {
		let sum = 0;
		for (let arg of args) {
			sum += arg;
		}
		return sum;
	}
----------------------------------------------------------
В старом варианте параметры можно было получить только через arguments.
	function showName() {
  		alert( arguments.length );
  		alert( arguments[0] );
  		alert( arguments[1] );

  		// Объект arguments можно перебирать
  		// for (let arg of arguments) alert(arg);
	}
Стрелочные функции не имеют arguments.	
----------------------------------------------------------
Оператор расширения (...arr):
	Пример:
		let arr = [3, 5, 1];
		alert(Math.max(...arr));
	Этот оператор можно использовать для слияния массивов:
		let arr1 = [3, 5, 1];
		let arr2 = [8, 9, 15];
		let merged = [0, ...arr1, 2, ...arr2];
	Оператор расширения работает только с итерируемыми объектами в отличии от Array.from.
----------------------------------------------------------
----------------------------------------------------------
Замыкание:
	У каждой функции в js есть скрытый объект, называемый лексическим окружением:
		1) environment record - объект, в котором храняться все локальный переменные + this;
		2) ссылка на внешнее лексическое окружение [Environment] - окружение досупное снаружи функции;
	Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
	Все функции в js являются замыканием.
	Пример:
		function sum(a) {
			return function(b) {
  				return a + b;
  			}
		}
		alert(sum(3)(5));	
	Пример immediately-invoked function expression:
		!function() {
  			alert("Выражение начинается с логического оператора NOT");
		}();

		+function() {
  			alert("Выражение начинается с унарного плюса");
		}();	
----------------------------------------------------------
----------------------------------------------------------
Глобальный объект:
	В браузере глобальным объектом является windows.
	Хранит переменные, которые должны быть доступны в любом месте программы.
----------------------------------------------------------
----------------------------------------------------------
Объект функции, NFE
	Функции в js - это объекты.
	Свойства функций: name, length.
	----------------------------------------------------------
	Интроспекция - в java это просто обычный cast
	Ad-hoc-полиморфизм поддерживается при помощи перезагрузки методов
	----------------------------------------------------------
	С помощью парметра length можно реализовать ad-hoc-полиморфизм
		function ask(question, ...handlers) {
			let isYes = confirm(question);
  			for(let handler of handlers) {
    			if (handler.length == 0) {
      				if (isYes) handler();
    			} else {
      				handler(isYes);
    			}
  			}
		}
	----------------------------------------------------------
	К функциям могут добавляться пользовательские свойства:
		function makeCounter() {
			function counter() {
				return counter.count++;
			}
			counter.count = 0;
			return counter;
		}
	----------------------------------------------------------
	Named Function Expression - Function Expression, у которого есть имя
		let sayHi = function func (who) {
			if (who) {
				alert(`Hello, ${who}`);
			} else {
				func('Guest');
			}	
		}
	Свойства:
		1) позволяет ссылаться на себя же;
		2) оно недоступно за пределами функции;
	----------------------------------------------------------	
	Пример использования NFE:
		function sum(a) {
  			let currentSum = a;
  			function f(b) {
    			currentSum += b;
    			return f;
  			}
  			f.toString = function() {
    			return currentSum;
  			};
  			return f;
		}	
		alert( sum(5)(-1)(2) );
		alert( sum(6)(-1)(-2)(-3) );
----------------------------------------------------------
----------------------------------------------------------		
Синтаксис new Function;
	Пример:
		let sum = new Function('a', 'b', 'return a + b');
		alert(sum(1, 2));	
		Такая функция не имеет ссылки на внешнее лексическое окружение.
----------------------------------------------------------
----------------------------------------------------------
	setTimeout - позволет вызвать функцию один раз чрезе определенный интервал времени;
	timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...); // передается ссылка на функцию
	можно отменить выполнение функции с помощью вызова clearTimeout(timerId);
	позволяет задовать задержку между выполнения функций более точно:
		let i = 1;
		setTimeout(function run() {
  			func(i);
  			setTimeout(run, 100);
		}, 100);
		каждый вызов функции будет выполняться именно через 100 млс
	----------------------------------------------------------
	setInterval - позволяет вызывать функцию регулярно, повторяя вызов через определенный интервал;
	let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
	----------------------------------------------------------
	необходимо вызывать функцию clearInterval(clearTimeout) для того, чтобы сборщик мусора 
	мог удалить функцию timer.
	----------------------------------------------------------
	Минимальная задержка вложенных таймеров после четвертого вызова должна быть не менее 4 млс.
	----------------------------------------------------------
	Все методы планирования не гарантируют точную задержку 
	(например таймер может замедляться, если процессор перегружен).
----------------------------------------------------------
----------------------------------------------------------
Декораторы и переадресация вызова, call/apply
	----------------------------------------------------------
	Пример декоратора функции:
		function show(x) {
			alert(x);
 		 	return x;
		}
		function cachingDecorator(func) {
			let map = new Map();
  			return function(x) {
  				if (map.has(x)) {
    				alert(x + 4);
    				return map.get(x);
    			}
    			let result = func(x);
    			map.set(x, result)
				return x;
  			}
		}	
		show = cachingDecorator(show);
	----------------------------------------------------------
	Передача контекста в функцию:
		----------------------------------------------------------
		func.call(context, arg1, arg2, ...) - вызывает функцию с указанным контекстом и аргументами
		// эта функция ожидает список аргументов.
			function sayHi(phrase) {
				alert(this.name + ': ' + phase);
			}
			let user = {name: 'John'};
			sayHi.call(user, 'Hello');
		----------------------------------------------------------
		func.apply(contex, args) - тоже самое, что и func call, но ожидает псевдомассив
		----------------------------------------------------------
		call forwarding - перенаправление вызова - передача всех аргументов с контекстом другой функции
		let wrapper = function() {
			return func.apply(this, arguments);
		}	
		----------------------------------------------------------
		заимствование метода:
			function hash () {
				alert([].join.call(arguments));
			}
		----------------------------------------------------------
		Пример функции с задержкой:
			function throttle(func, ms) {

			  let isThrottled = false,
			    savedArgs,
			    savedThis;

			  function wrapper() {

			    if (isThrottled) { // (2)
			      savedArgs = arguments;
			      savedThis = this;
			      return;
			    }

			    func.apply(this, arguments); // (1)

			    isThrottled = true;

			    setTimeout(function() {
			      isThrottled = false; // (3)
			      if (savedArgs) {
			        wrapper.apply(savedThis, savedArgs);
			        savedArgs = savedThis = null;
			      }
			    }, ms);
			  }

			  return wrapper;
			}
----------------------------------------------------------
----------------------------------------------------------
Привязка контекста к функции:
	bind - позволяет зафиксировать this, также с помощью bind можно привязать и аргументы к функции
		let boundFunc = func.bind(context);
		Пример привязки аргументов:
			function mul(a, b) {
  				return a * b;
			}
			let double = mul.bind(null, 2);
			
